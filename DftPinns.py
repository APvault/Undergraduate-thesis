# -*- coding: utf-8 -*-
"""CO2_CASE_STUDY.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17q1LE04r-8fn6RDvfolWwnqzl5EYMl5D

SCF-DFT USING PYSCF
"""

# Install PySCF if not already installed
!pip install pyscf
# Import required libraries
from pyscf import gto, dft
import numpy as np
import matplotlib.pyplot as plt

# Conversion factor: Ångströms to Bohr
angstrom_to_bohr = 1.8897259886

# List of bond lengths to compute (in Ångströms), from 0.5 Å to 2.0 Å with 0.25 Å step size
bond_lengths = np.arange(0.5, 2.01, 0.25).tolist()  # [0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]

# List to store energies for plotting
energies = []

# Loop over each bond length
for bond_length in bond_lengths:
    # Define the CO2 molecule with the current bond length (fixed geometry, units in Ångströms)
    mol = gto.Mole()
    mol.atom = f'''
        C  0.0  0.0  0.0
        O  {bond_length} 0.0  0.0
        O -{bond_length} 0.0  0.0
    '''
    mol.basis = 'cc-pvdz'  # Simple basis set
    mol.symmetry = True    # Exploit symmetry
    mol.unit = 'angstroms'  # Explicitly set units to Ångströms for atomic coordinates
    mol.build()            # Build the molecule object

    # Set up the DFT calculation with LDA
    mf = dft.RKS(mol)
    mf.xc = 'LDA'           # Simplest LDA functional
    mf.verbose = 0          # Suppress detailed output for clarity (set to 4 for details)

    # Run a single-point DFT calculation
    energy = mf.kernel()
    energies.append(energy)  # Store energy for plotting

    # Define a 1D grid along the x-axis (y=0, z=0) with 500 points (units in Ångströms for plotting)
    x = np.linspace(-4.0, 4.0, 500)  # x-axis range in Å, 500 points (0.016 Å per point)

    # Convert the grid to Bohr units for PySCF's internal computation
    x_bohr = x * angstrom_to_bohr  # Convert Ångströms to Bohr
    grid_coords = np.zeros((x.size, 3))  # Grid into (N, 3) array/
    grid_coords[:, 0] = x_bohr       # x coordinates in Bohr (y=0, z=0 by default)

    # Compute electron density on the grid
    density = mf.make_rdm1()
    ao = mol.eval_gto('GTOval', grid_coords)
    rho = np.einsum('ij,pi,pj->p', density, ao, ao)

    # Convert electron density units from e/Bohr³ to e/Å³ for consistency in the plot
    bohr_to_angstrom = 1 / angstrom_to_bohr  # 1 Bohr = 0.529177249 Å
    rho = rho * (bohr_to_angstrom ** 3)  # Convert e/Bohr³ to e/Å³ (density scales with volume, so factor is (Bohr/Å)³)

    # Find the positions of the peaks in the electron density (in Ångströms)
    peak_indices = np.where(rho > np.max(rho) * 0.5)[0]  # Indices where density is significant
    peak_positions = x[peak_indices]  # x positions of the peaks (in Ångströms)
    print(f"Peak positions (Å): {peak_positions}")

    # Plot the 1D electron density with linear scaling
    plt.figure(figsize=(10, 6))
    plt.plot(x, rho, label='Electron Density', color='blue')  # Plot raw electron density
    plt.xlabel('x (Å)', fontsize=14)  # x-axis in Ångströms, larger font
    plt.ylabel('Electron Density (e/Å³)', fontsize=14)  # Electron density in e/Å³, linear scale, larger font
    plt.title(f'1D Electron Density of CO2 along x-axis (LDA, Bond Length {bond_length} Å)', fontsize=14)
    plt.grid(True)

    # Mark atom positions (in Ångströms)
    plt.axvline(x=0.0, color='red', linestyle='--', label='C (x=0)')          # Carbon at x=0 Å
    plt.axvline(x=bond_length, color='green', linestyle='--', label=f'O (x={bond_length})')  # O1 at x=bond_length Å
    plt.axvline(x=-bond_length, color='green', linestyle='--', label=f'O (x=-{bond_length})') # O2 at x=-bond_length Å
    plt.legend(fontsize=12)  # Larger font for legend
    plt.show()

    # Print bond lengths and ground state energy
    print(f"\nResults for Bond Length: {bond_length} Å")
    print(f"C-O1 Bond Length (fixed): {bond_length} Å")
    print(f"C-O2 Bond Length (fixed): {bond_length} Å")
    print(f"Ground State Energy (SCF) at Fixed Geometry: {energy:.6f} Hartree")

# Plot Bond Length vs Energy
plt.figure(figsize=(10, 6))
plt.plot(bond_lengths, energies, 'bo-', label='LDA Energy')
plt.xlabel('C-O Bond Length (Å)', fontsize=14)
plt.ylabel('Ground State Energy (Hartree)', fontsize=14)
plt.title('CO2 Bond Length vs Ground State Energy (LDA)', fontsize=14)
plt.grid(True)
plt.legend(fontsize=12)  # Larger font for legend
plt.show()

"""DFT-PINNS"""

import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt

# Device setup
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

# Physical constants
bohr_to_angstrom = 5.29177210903e-1  # Å/bohr
hartree_to_ev = 27.2114  # eV/Hartree

# CO2 parameters
Z_C = 6  # Carbon nuclear charge
Z_O = 8  # Oxygen nuclear charge
n_electrons = 22  # Total electrons
r_co = 1.00  # C-O bond length (Å)

# Neural network for orbitals
class OrbitalNet(nn.Module):
    def __init__(self, n_orbitals=11, hidden_size=64):
        super(OrbitalNet, self).__init__()
        self.n_orbitals = n_orbitals
        self.net = nn.Sequential(
            nn.Linear(1, hidden_size),
            nn.Tanh(),
            nn.Linear(hidden_size, hidden_size),
            nn.Tanh(),
            nn.Linear(hidden_size, n_orbitals)
        )
        self.centers = nn.Parameter(torch.tensor([0.0, r_co, -r_co] * (n_orbitals // 3 + 1))[:n_orbitals].to(device))
        self.sigma = nn.Parameter(torch.ones(n_orbitals, device=device) * 0.5)

    def forward(self, x):
        psi_nn = self.net(x)
        psi_init = torch.zeros_like(psi_nn)
        for i in range(self.n_orbitals):
            psi_init[:, i] = torch.exp(-((x.squeeze() - self.centers[i])**2) / (2 * self.sigma[i]**2))
        psi = psi_nn + psi_init
        decay = torch.exp(-torch.abs(x) / 1.0)
        psi = psi * decay
        return psi

# Nuclear potential
def nuclear_potential(x, r_co, softening=0.05):
    x_au = x / bohr_to_angstrom
    r_co_au = r_co / bohr_to_angstrom
    softening_au = softening / bohr_to_angstrom
    pos_C, pos_O1, pos_O2 = 0.0, r_co_au, -r_co_au
    r_C = torch.sqrt((x_au - pos_C)**2 + softening_au**2)
    r_O1 = torch.sqrt((x_au - pos_O1)**2 + softening_au**2)
    r_O2 = torch.sqrt((x_au - pos_O2)**2 + softening_au**2)
    V_nuc = -Z_C / r_C - Z_O / r_O1 - Z_O / r_O2
    return V_nuc

# Kinetic energy
def compute_kinetic_energy(model, x, dx):
    x = x.requires_grad_(True)
    psi = model(x)
    T_total = 0.0
    for i in range(model.n_orbitals):
        psi_i = psi[:, i]
        grad_outputs = torch.ones_like(psi_i)
        psi_x = torch.autograd.grad(psi_i, x, grad_outputs=grad_outputs, create_graph=True)[0]
        T_i = 0.5 * torch.mean(psi_x**2)
        T_total += T_i
    return T_total

# Hartree potential
def compute_hartree_potential(rho, x, dx, epsilon=0.05):
    x_au = x / bohr_to_angstrom
    dx_au = dx / bohr_to_angstrom
    rho_au = rho * bohr_to_angstrom
    epsilon_au = epsilon / bohr_to_angstrom
    n_points = x.shape[0]
    V_h = torch.zeros(n_points, device=device)
    for i in range(n_points):
        r_diff = torch.sqrt((x_au[i] - x_au)**2 + epsilon_au**2)
        V_h[i] = torch.sum(rho_au / r_diff) * dx_au
    return V_h

# Kohn-Sham energy functional
def compute_energy(model, x, r_co, dx):
    psi = model(x)
    rho = 2 * torch.sum(psi**2, dim=1)
    T = compute_kinetic_energy(model, x, dx)
    V_nuc = nuclear_potential(x.squeeze(), r_co)
    E_nuc = torch.sum(rho * V_nuc) * dx
    V_h = compute_hartree_potential(rho, x.squeeze(), dx)
    E_h = 0.5 * torch.sum(rho * V_h) * dx
    rho_au = rho * bohr_to_angstrom
    epsilon_xc = -0.75 * (3 / np.pi)**(1/3) * torch.pow(torch.clamp(rho_au, min=1e-6), 1/3)
    E_xc = torch.sum(rho * epsilon_xc) * dx
    r_co_au = torch.tensor(r_co / bohr_to_angstrom, device=device)
    E_nn = 2 * (Z_C * Z_O / r_co_au) + (Z_O * Z_O / (2 * r_co_au))
    E_nn = E_nn.to(device)
    E_total = T + E_nuc + E_h + E_xc + E_nn
    return E_total, rho, T, E_nuc, E_h, E_xc, E_nn

# Training function
def train_model(r_co=1.00, num_points=1000, epochs=20000):
    model = OrbitalNet(n_orbitals=11).to(device)
    optimizer = optim.Adam(model.parameters(), lr=0.000099)
    scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, 'min', factor=0.5, patience=1000)
    x = torch.linspace(-4.0, 4.0, num_points, device=device).unsqueeze(1)
    dx = (x[1] - x[0]).item()

    losses, energies, T_vals, E_nuc_vals, E_h_vals, E_xc_vals, E_nn_vals = [], [], [], [], [], [], []

    min_loss, min_loss_epoch, min_loss_energy = float('inf'), 0, 0.0

    for epoch in range(epochs):
        optimizer.zero_grad()
        E_total, rho, T, E_nuc, E_h, E_xc, E_nn = compute_energy(model, x, r_co, dx)
        n_pred = torch.sum(rho) * dx
        loss_norm = 100*(n_pred - n_electrons)**2
        loss = E_total + loss_norm
        loss.backward()
        torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
        optimizer.step()
        scheduler.step(loss)

        losses.append(loss.item())
        energies.append(E_total.item())
        T_vals.append(T.item())
        E_nuc_vals.append(E_nuc.item())
        E_h_vals.append(E_h.item())
        E_xc_vals.append(E_xc.item())
        E_nn_vals.append(E_nn.item())

        if loss.item() < min_loss:
            min_loss = loss.item()
            min_loss_epoch = epoch
            min_loss_energy = E_total.item()

        if epoch % 200 == 0:
            print(f"Epoch {epoch}:")
            print(f"  Total Energy: {E_total.item():.4f} Hartree")
            print(f"  Loss: {loss.item():.4f}")
            print(f"  Electrons: {n_pred.item():.2f}")
            print(f"  T: {T.item():.4f}, E_nuc: {E_nuc.item():.4f}, E_h: {E_h.item():.4f}, E_xc: {E_xc.item():.4f}, E_nn: {E_nn.item():.4f}")

    print(f"\nLowest Loss at Epoch {min_loss_epoch}:")
    print(f"  Loss: {min_loss:.4f}")
    print(f"  Energy at Lowest Loss: {min_loss_energy:.4f} Hartree")

    return model, x, dx, losses, energies, T_vals, E_nuc_vals, E_h_vals, E_xc_vals, E_nn_vals

# Plotting functions with larger labels and legends
def plot_density(model, x, r_co, dx):
    with torch.no_grad():
        psi = model(x)
        rho = 2 * torch.sum(psi**2, dim=1)
    x_np = x.detach().cpu().numpy().squeeze()
    rho_np = rho.detach().cpu().numpy()
    plt.figure(figsize=(10, 6))
    plt.plot(x_np, rho_np, label='Electron Density')
    plt.axvline(0, color='r', linestyle='--', label='Carbon')
    plt.axvline(r_co, color='b', linestyle='--', label='Oxygen')
    plt.axvline(-r_co, color='b', linestyle='--')
    plt.title(f'CO2 Electron Density (1D) at r_CO = {r_co} Å', fontsize=20)
    plt.xlabel('x (Å)', fontsize=20)
    plt.ylabel('Electron Density (electrons/Å)', fontsize=20)
    plt.legend(fontsize=16)
    plt.grid(True)
    plt.show()

def plot_orbitals(model, x, r_co):
    with torch.no_grad():
        psi = model(x)
    x_np = x.detach().cpu().numpy().squeeze()
    psi_np = psi.detach().cpu().numpy()
    plt.figure(figsize=(10, 6))
    for i in range(model.n_orbitals):
        plt.plot(x_np, psi_np[:, i], label=f'Orbital {i+1}')
    plt.axvline(0, color='r', linestyle='--', label='Carbon')
    plt.axvline(r_co, color='b', linestyle='--', label='Oxygen')
    plt.axvline(-r_co, color='b', linestyle='--')
    plt.title(f'CO2 Kohn-Sham Orbitals (1D) at r_CO = {r_co} Å', fontsize=20)
    plt.xlabel('x (Å)', fontsize=20)
    plt.ylabel('ψ(x)', fontsize=20)
    plt.legend(fontsize=12)
    plt.grid(True)
    plt.show()

def plot_training_progress(energies, losses):
    plt.figure(figsize=(12, 5))
    epochs_range = range(len(energies))

    plt.subplot(1, 2, 1)
    plt.plot(epochs_range, energies, label='Total Energy', color='blue')
    plt.xlabel('Epoch', fontsize=14)
    plt.ylabel('Energy (Hartree)', fontsize=20)
    plt.title('Energy vs Epoch', fontsize=20)
    plt.legend(fontsize=12)
    plt.grid(True)

    plt.subplot(1, 2, 2)
    plt.plot(epochs_range, losses, label='Loss', color='red')
    plt.xlabel('Epoch', fontsize=20)
    plt.ylabel('Loss', fontsize=20)
    plt.title('Loss vs Epoch', fontsize=20)
    plt.legend(fontsize=20)
    plt.grid(True)

    plt.tight_layout()
    plt.show()

def plot_energy_components(T_vals, E_nuc_vals, E_h_vals, E_xc_vals, E_nn_vals):
    plt.figure(figsize=(10, 6))
    epochs_range = range(len(T_vals))
    plt.plot(epochs_range, T_vals, label='Kinetic Energy (T)', color='blue')
    plt.plot(epochs_range, E_nuc_vals, label='Nuclear Potential (E_nuc)', color='green')
    plt.plot(epochs_range, E_h_vals, label='Hartree Energy (E_h)', color='red')
    plt.plot(epochs_range, E_xc_vals, label='Exchange-Correlation (E_xc)', color='purple')
    plt.plot(epochs_range, E_nn_vals, label='Nuclear-Nuclear (E_nn)', color='orange')
    plt.xlabel('Epoch', fontsize=14)
    plt.ylabel('Energy (Hartree)', fontsize=14)
    plt.title('Energy Components vs Epoch', fontsize=16)
    plt.legend(fontsize=10)
    plt.grid(True)
    plt.show()

# Run simulation
model, x, dx, losses, energies, T_vals, E_nuc_vals, E_h_vals, E_xc_vals, E_nn_vals = train_model(r_co=1.00, num_points=1000, epochs=20000)
E_total, rho, T, E_nuc, E_h, E_xc, E_nn = compute_energy(model, x, 1.00, dx)
print(f"\nFinal Ground-State Energy: {E_total.item():.4f} Hartree")
print(f"Electrons: {torch.sum(rho * dx).item():.2f}")

# Plot results
plot_density(model, x, 1.00, dx)b
plot_training_progress(energies, losses)
plot_orbitals(model, x, 1.00)
plot_energy_components(T_vals, E_nuc_vals, E_h_vals, E_xc_vals, E_nn_vals)